
-- ====================================================================
-- SISTEMA FINANCEIRO FAMILIAR KIGI - SCRIPTS ORACLE 11G
-- ====================================================================
-- 
-- Descrição: Scripts para criação das tabelas, índices, constraints
-- e relacionamentos do sistema financeiro familiar KIGI
-- 
-- ESTRUTURA ATUAL: Saídas unificadas com tipos (normal, parcelada_pai, parcela)
-- Prefixo: KIG_ em todos os objetos de banco
-- Versão: Oracle Database 11G - REVISÃO COMPLETA ATUALIZADA
-- Data: Janeiro 2025
-- ====================================================================

-- ====================================================================
-- 1. CRIAÇÃO DAS SEQUENCES PARA IDs AUTOINCREMENTAIS
-- ====================================================================

-- Sequence para tabela KIG_USUARIOS
CREATE SEQUENCE KIG_SEQ_USUARIOS
    START WITH 1
    INCREMENT BY 1
    NOMAXVALUE
    NOCACHE;

-- Sequence para tabela KIG_EMPRESAS
CREATE SEQUENCE KIG_SEQ_EMPRESAS
    START WITH 1
    INCREMENT BY 1
    NOMAXVALUE
    NOCACHE;

-- Sequence para tabela KIG_PRODUTOS
CREATE SEQUENCE KIG_SEQ_PRODUTOS
    START WITH 1
    INCREMENT BY 1
    NOMAXVALUE
    NOCACHE;

-- Sequence para tabela KIG_ENTRADAS
CREATE SEQUENCE KIG_SEQ_ENTRADAS
    START WITH 1
    INCREMENT BY 1
    NOMAXVALUE
    NOCACHE;

-- Sequence para tabela KIG_SAIDAS
CREATE SEQUENCE KIG_SEQ_SAIDAS
    START WITH 1
    INCREMENT BY 1
    NOMAXVALUE
    NOCACHE;

-- Sequence para tabela KIG_ITENS_SAIDA
CREATE SEQUENCE KIG_SEQ_ITENS_SAIDA
    START WITH 1
    INCREMENT BY 1
    NOMAXVALUE
    NOCACHE;

-- Sequence para tabela KIG_SAIDA_TITULARES
CREATE SEQUENCE KIG_SEQ_SAIDA_TITULARES
    START WITH 1
    INCREMENT BY 1
    NOMAXVALUE
    NOCACHE;

-- ====================================================================
-- 2. CRIAÇÃO DAS TABELAS PRINCIPAIS
-- ====================================================================

-- TABELA: KIG_USUARIOS
-- Armazena os usuários da família (pai, mãe, filhos)
-- Atualizada conforme estrutura atual do sistema
CREATE TABLE KIG_USUARIOS (
    ID NUMBER(10) PRIMARY KEY,
    NOME VARCHAR2(100) NOT NULL,
    LOGIN VARCHAR2(50) NOT NULL UNIQUE,
    SENHA VARCHAR2(255) NOT NULL,
    PAPEL VARCHAR2(10) NOT NULL CHECK (PAPEL IN ('pai', 'mae', 'filho', 'filha')),
    ATIVO NUMBER(1) DEFAULT 1 CHECK (ATIVO IN (0, 1)),
    CRIADO_EM TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ATUALIZADO_EM TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- TABELA: KIG_EMPRESAS
-- Armazena as empresas onde são realizadas compras/pagamentos
-- Estrutura simplificada conforme uso atual no sistema
CREATE TABLE KIG_EMPRESAS (
    ID NUMBER(10) PRIMARY KEY,
    NOME VARCHAR2(200) NOT NULL,
    ATIVO NUMBER(1) DEFAULT 1 CHECK (ATIVO IN (0, 1)),
    CRIADO_EM TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ATUALIZADO_EM TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- TABELA: KIG_PRODUTOS
-- Armazena o catálogo de produtos da família
-- Estrutura atualizada conforme implementação atual
CREATE TABLE KIG_PRODUTOS (
    ID NUMBER(10) PRIMARY KEY,
    CODIGO_BARRAS VARCHAR2(50),
    NOME VARCHAR2(200) NOT NULL,
    UNIDADE VARCHAR2(20) NOT NULL,
    CLASSIFICACAO VARCHAR2(100) NOT NULL,
    ATIVO NUMBER(1) DEFAULT 1 CHECK (ATIVO IN (0, 1)),
    CRIADO_EM TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ATUALIZADO_EM TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- TABELA: KIG_ENTRADAS
-- Armazena as receitas/entradas financeiras da família
-- Estrutura conforme interface EntradaInput atual
CREATE TABLE KIG_ENTRADAS (
    ID NUMBER(10) PRIMARY KEY,
    USUARIO_REGISTRO_ID NUMBER(10) NOT NULL,
    DATA_HORA_REGISTRO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    USUARIO_TITULAR_ID NUMBER(10) NOT NULL,
    DATA_REFERENCIA DATE NOT NULL,
    VALOR NUMBER(15,2) NOT NULL CHECK (VALOR > 0),
    EMPRESA_PAGADORA_ID NUMBER(10) NOT NULL,
    CONSTRAINT FK_KIG_ENTRADA_USUARIO_REGISTRO FOREIGN KEY (USUARIO_REGISTRO_ID) REFERENCES KIG_USUARIOS(ID),
    CONSTRAINT FK_KIG_ENTRADA_USUARIO_TITULAR FOREIGN KEY (USUARIO_TITULAR_ID) REFERENCES KIG_USUARIOS(ID),
    CONSTRAINT FK_KIG_ENTRADA_EMPRESA_PAGADORA FOREIGN KEY (EMPRESA_PAGADORA_ID) REFERENCES KIG_EMPRESAS(ID)
);

-- TABELA: KIG_SAIDAS
-- ESTRUTURA UNIFICADA: Saídas à vista e parceladas em uma única tabela
-- Conforme interface Saida e SaidaInput atuais do sistema
CREATE TABLE KIG_SAIDAS (
    ID NUMBER(10) PRIMARY KEY,
    SAIDA_PAI_ID NUMBER(10), -- Referência à saída pai (NULL para saídas normais e saídas_pai)
    TIPO_SAIDA VARCHAR2(20) DEFAULT 'normal' CHECK (TIPO_SAIDA IN ('normal', 'parcelada_pai', 'parcela')),
    NUMERO_PARCELA NUMBER(3) DEFAULT 1 CHECK (NUMERO_PARCELA > 0),
    TOTAL_PARCELAS NUMBER(3), -- Preenchido apenas para saídas parceladas (pai)
    USUARIO_REGISTRO_ID NUMBER(10) NOT NULL,
    DATA_HORA_REGISTRO TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DATA_SAIDA DATE NOT NULL, -- Data de impacto financeiro (vencimento da parcela)
    EMPRESA_ID NUMBER(10) NOT NULL,
    TIPO_PAGAMENTO VARCHAR2(10) NOT NULL CHECK (TIPO_PAGAMENTO IN ('avista', 'parcelado')),
    VALOR_TOTAL NUMBER(15,2) NOT NULL CHECK (VALOR_TOTAL > 0),
    OBSERVACAO VARCHAR2(500),
    CONSTRAINT FK_KIG_SAIDA_USUARIO_REGISTRO FOREIGN KEY (USUARIO_REGISTRO_ID) REFERENCES KIG_USUARIOS(ID),
    CONSTRAINT FK_KIG_SAIDA_EMPRESA FOREIGN KEY (EMPRESA_ID) REFERENCES KIG_EMPRESAS(ID),
    CONSTRAINT FK_KIG_SAIDA_PAI FOREIGN KEY (SAIDA_PAI_ID) REFERENCES KIG_SAIDAS(ID),
    -- Constraints de integridade da estrutura unificada
    CONSTRAINT CHK_KIG_SAIDA_AVISTA CHECK (
        (TIPO_PAGAMENTO = 'avista' AND TIPO_SAIDA = 'normal' AND SAIDA_PAI_ID IS NULL AND NUMERO_PARCELA = 1) OR
        (TIPO_PAGAMENTO = 'parcelado')
    ),
    CONSTRAINT CHK_KIG_SAIDA_PARCELADA_PAI CHECK (
        (TIPO_SAIDA = 'parcelada_pai' AND SAIDA_PAI_ID IS NULL AND TOTAL_PARCELAS > 1) OR
        (TIPO_SAIDA != 'parcelada_pai')
    ),
    CONSTRAINT CHK_KIG_SAIDA_PARCELA_FILHA CHECK (
        (TIPO_SAIDA = 'parcela' AND SAIDA_PAI_ID IS NOT NULL AND TOTAL_PARCELAS IS NULL) OR
        (TIPO_SAIDA != 'parcela')
    ),
    CONSTRAINT CHK_KIG_NUMERO_PARCELA_CONSISTENTE CHECK (
        (TIPO_SAIDA = 'normal' AND NUMERO_PARCELA = 1) OR
        (TIPO_SAIDA IN ('parcelada_pai', 'parcela') AND NUMERO_PARCELA >= 1)
    )
);

-- TABELA: KIG_ITENS_SAIDA
-- Armazena os itens individuais de cada saída/despesa
-- Conforme interface ItemSaida atual
CREATE TABLE KIG_ITENS_SAIDA (
    ID NUMBER(10) PRIMARY KEY,
    SAIDA_ID NUMBER(10) NOT NULL,
    PRODUTO_ID NUMBER(10) NOT NULL,
    NOME_PRODUTO VARCHAR2(200) NOT NULL,
    QUANTIDADE NUMBER(10,3) NOT NULL CHECK (QUANTIDADE > 0),
    PRECO_UNITARIO NUMBER(15,2) NOT NULL CHECK (PRECO_UNITARIO > 0),
    TOTAL NUMBER(15,2) NOT NULL CHECK (TOTAL > 0),
    CONSTRAINT FK_KIG_ITEM_SAIDA FOREIGN KEY (SAIDA_ID) REFERENCES KIG_SAIDAS(ID) ON DELETE CASCADE,
    CONSTRAINT FK_KIG_ITEM_PRODUTO FOREIGN KEY (PRODUTO_ID) REFERENCES KIG_PRODUTOS(ID),
    CONSTRAINT CHK_KIG_TOTAL_ITEM CHECK (ABS(TOTAL - (QUANTIDADE * PRECO_UNITARIO)) < 0.01)
);

-- TABELA: KIG_SAIDA_TITULARES
-- Tabela de relacionamento many-to-many entre saídas e usuários titulares
-- Conforme usuariosTitularesIds[] da interface atual
CREATE TABLE KIG_SAIDA_TITULARES (
    ID NUMBER(10) PRIMARY KEY,
    SAIDA_ID NUMBER(10) NOT NULL,
    USUARIO_ID NUMBER(10) NOT NULL,
    CONSTRAINT FK_KIG_SAIDA_TITULAR_SAIDA FOREIGN KEY (SAIDA_ID) REFERENCES KIG_SAIDAS(ID) ON DELETE CASCADE,
    CONSTRAINT FK_KIG_SAIDA_TITULAR_USUARIO FOREIGN KEY (USUARIO_ID) REFERENCES KIG_USUARIOS(ID),
    CONSTRAINT UK_KIG_SAIDA_USUARIO UNIQUE (SAIDA_ID, USUARIO_ID)
);

-- ====================================================================
-- 3. CRIAÇÃO DOS ÍNDICES PARA OTIMIZAÇÃO
-- ====================================================================

-- Índices para tabela KIG_USUARIOS
CREATE INDEX IDX_KIG_USUARIOS_LOGIN ON KIG_USUARIOS(LOGIN);
CREATE INDEX IDX_KIG_USUARIOS_PAPEL ON KIG_USUARIOS(PAPEL);
CREATE INDEX IDX_KIG_USUARIOS_ATIVO ON KIG_USUARIOS(ATIVO);

-- Índices para tabela KIG_EMPRESAS
CREATE INDEX IDX_KIG_EMPRESAS_NOME ON KIG_EMPRESAS(NOME);
CREATE INDEX IDX_KIG_EMPRESAS_ATIVO ON KIG_EMPRESAS(ATIVO);

-- Índices para tabela KIG_PRODUTOS
CREATE INDEX IDX_KIG_PRODUTOS_CODIGO_BARRAS ON KIG_PRODUTOS(CODIGO_BARRAS);
CREATE INDEX IDX_KIG_PRODUTOS_NOME ON KIG_PRODUTOS(NOME);
CREATE INDEX IDX_KIG_PRODUTOS_CLASSIFICACAO ON KIG_PRODUTOS(CLASSIFICACAO);
CREATE INDEX IDX_KIG_PRODUTOS_ATIVO ON KIG_PRODUTOS(ATIVO);

-- Índices para tabela KIG_ENTRADAS
CREATE INDEX IDX_KIG_ENTRADAS_USUARIO_REGISTRO ON KIG_ENTRADAS(USUARIO_REGISTRO_ID);
CREATE INDEX IDX_KIG_ENTRADAS_USUARIO_TITULAR ON KIG_ENTRADAS(USUARIO_TITULAR_ID);
CREATE INDEX IDX_KIG_ENTRADAS_DATA_REFERENCIA ON KIG_ENTRADAS(DATA_REFERENCIA);
CREATE INDEX IDX_KIG_ENTRADAS_EMPRESA_PAGADORA ON KIG_ENTRADAS(EMPRESA_PAGADORA_ID);
CREATE INDEX IDX_KIG_ENTRADAS_DATA_HORA_REGISTRO ON KIG_ENTRADAS(DATA_HORA_REGISTRO);

-- Índices para tabela KIG_SAIDAS (ESTRUTURA UNIFICADA)
CREATE INDEX IDX_KIG_SAIDAS_USUARIO_REGISTRO ON KIG_SAIDAS(USUARIO_REGISTRO_ID);
CREATE INDEX IDX_KIG_SAIDAS_DATA_SAIDA ON KIG_SAIDAS(DATA_SAIDA);
CREATE INDEX IDX_KIG_SAIDAS_EMPRESA ON KIG_SAIDAS(EMPRESA_ID);
CREATE INDEX IDX_KIG_SAIDAS_TIPO_PAGAMENTO ON KIG_SAIDAS(TIPO_PAGAMENTO);
CREATE INDEX IDX_KIG_SAIDAS_TIPO_SAIDA ON KIG_SAIDAS(TIPO_SAIDA);
CREATE INDEX IDX_KIG_SAIDAS_SAIDA_PAI ON KIG_SAIDAS(SAIDA_PAI_ID);
CREATE INDEX IDX_KIG_SAIDAS_NUMERO_PARCELA ON KIG_SAIDAS(NUMERO_PARCELA);
CREATE INDEX IDX_KIG_SAIDAS_DATA_HORA_REGISTRO ON KIG_SAIDAS(DATA_HORA_REGISTRO);

-- Índices para tabela KIG_ITENS_SAIDA
CREATE INDEX IDX_KIG_ITENS_SAIDA_SAIDA ON KIG_ITENS_SAIDA(SAIDA_ID);
CREATE INDEX IDX_KIG_ITENS_SAIDA_PRODUTO ON KIG_ITENS_SAIDA(PRODUTO_ID);

-- Índices para tabela KIG_SAIDA_TITULARES
CREATE INDEX IDX_KIG_SAIDA_TITULARES_SAIDA ON KIG_SAIDA_TITULARES(SAIDA_ID);
CREATE INDEX IDX_KIG_SAIDA_TITULARES_USUARIO ON KIG_SAIDA_TITULARES(USUARIO_ID);

-- ====================================================================
-- 4. CRIAÇÃO DOS TRIGGERS PARA IDs AUTOINCREMENTAIS
-- ====================================================================

-- Trigger para tabela KIG_USUARIOS
CREATE OR REPLACE TRIGGER TRG_KIG_USUARIOS_ID
    BEFORE INSERT ON KIG_USUARIOS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT KIG_SEQ_USUARIOS.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

-- Trigger para tabela KIG_EMPRESAS
CREATE OR REPLACE TRIGGER TRG_KIG_EMPRESAS_ID
    BEFORE INSERT ON KIG_EMPRESAS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT KIG_SEQ_EMPRESAS.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

-- Trigger para tabela KIG_PRODUTOS
CREATE OR REPLACE TRIGGER TRG_KIG_PRODUTOS_ID
    BEFORE INSERT ON KIG_PRODUTOS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT KIG_SEQ_PRODUTOS.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

-- Trigger para tabela KIG_ENTRADAS
CREATE OR REPLACE TRIGGER TRG_KIG_ENTRADAS_ID
    BEFORE INSERT ON KIG_ENTRADAS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT KIG_SEQ_ENTRADAS.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

-- Trigger para tabela KIG_SAIDAS
CREATE OR REPLACE TRIGGER TRG_KIG_SAIDAS_ID
    BEFORE INSERT ON KIG_SAIDAS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT KIG_SEQ_SAIDAS.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

-- Trigger para tabela KIG_ITENS_SAIDA
CREATE OR REPLACE TRIGGER TRG_KIG_ITENS_SAIDA_ID
    BEFORE INSERT ON KIG_ITENS_SAIDA
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT KIG_SEQ_ITENS_SAIDA.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

-- Trigger para tabela KIG_SAIDA_TITULARES
CREATE OR REPLACE TRIGGER TRG_KIG_SAIDA_TITULARES_ID
    BEFORE INSERT ON KIG_SAIDA_TITULARES
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT KIG_SEQ_SAIDA_TITULARES.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

-- ====================================================================
-- 5. TRIGGERS PARA ATUALIZAÇÃO AUTOMÁTICA DE TIMESTAMPS
-- ====================================================================

-- Trigger para atualizar campo ATUALIZADO_EM na tabela KIG_USUARIOS
CREATE OR REPLACE TRIGGER TRG_KIG_USUARIOS_UPDATED
    BEFORE UPDATE ON KIG_USUARIOS
    FOR EACH ROW
BEGIN
    :NEW.ATUALIZADO_EM := CURRENT_TIMESTAMP;
END;
/

-- Trigger para atualizar campo ATUALIZADO_EM na tabela KIG_EMPRESAS
CREATE OR REPLACE TRIGGER TRG_KIG_EMPRESAS_UPDATED
    BEFORE UPDATE ON KIG_EMPRESAS
    FOR EACH ROW
BEGIN
    :NEW.ATUALIZADO_EM := CURRENT_TIMESTAMP;
END;
/

-- Trigger para atualizar campo ATUALIZADO_EM na tabela KIG_PRODUTOS
CREATE OR REPLACE TRIGGER TRG_KIG_PRODUTOS_UPDATED
    BEFORE UPDATE ON KIG_PRODUTOS
    FOR EACH ROW
BEGIN
    :NEW.ATUALIZADO_EM := CURRENT_TIMESTAMP;
END;
/

-- ====================================================================
-- 6. TRIGGERS DE VALIDAÇÃO E INTEGRIDADE DE NEGÓCIO
-- ====================================================================

-- Trigger para validar se o valor total da saída corresponde à soma dos itens
CREATE OR REPLACE TRIGGER TRG_KIG_VALIDAR_TOTAL_SAIDA
    AFTER INSERT OR UPDATE OR DELETE ON KIG_ITENS_SAIDA
    FOR EACH ROW
DECLARE
    V_SAIDA_ID NUMBER(10);
    V_TOTAL_CALCULADO NUMBER(15,2);
    V_TOTAL_SAIDA NUMBER(15,2);
BEGIN
    -- Determinar o ID da saída afetada
    IF INSERTING OR UPDATING THEN
        V_SAIDA_ID := :NEW.SAIDA_ID;
    ELSIF DELETING THEN
        V_SAIDA_ID := :OLD.SAIDA_ID;
    END IF;
    
    -- Calcular total dos itens
    SELECT NVL(SUM(TOTAL), 0) INTO V_TOTAL_CALCULADO
    FROM KIG_ITENS_SAIDA
    WHERE SAIDA_ID = V_SAIDA_ID;
    
    -- Obter valor total da saída
    SELECT VALOR_TOTAL INTO V_TOTAL_SAIDA
    FROM KIG_SAIDAS
    WHERE ID = V_SAIDA_ID;
    
    -- Validar se os totais são consistentes (tolerância de 1 centavo)
    IF ABS(V_TOTAL_CALCULADO - V_TOTAL_SAIDA) > 0.01 THEN
        RAISE_APPLICATION_ERROR(-20001, 
            'Total dos itens (' || V_TOTAL_CALCULADO || 
            ') não confere com o total da saída (' || V_TOTAL_SAIDA || ')');
    END IF;
END;
/

-- Trigger para validação específica da estrutura de parcelas
CREATE OR REPLACE TRIGGER TRG_KIG_VALIDAR_ESTRUTURA_PARCELAS
    BEFORE INSERT OR UPDATE ON KIG_SAIDAS
    FOR EACH ROW
DECLARE
    V_SAIDA_PAI_TIPO VARCHAR2(20);
    V_SAIDA_PAI_TOTAL_PARCELAS NUMBER(3);
    V_PARCELAS_EXISTENTES NUMBER(3);
BEGIN
    -- Validações para parcelas filhas
    IF :NEW.TIPO_SAIDA = 'parcela' THEN
        -- Verificar se a saída pai existe e é do tipo correto
        SELECT TIPO_SAIDA, TOTAL_PARCELAS 
        INTO V_SAIDA_PAI_TIPO, V_SAIDA_PAI_TOTAL_PARCELAS
        FROM KIG_SAIDAS 
        WHERE ID = :NEW.SAIDA_PAI_ID;
        
        -- Saída pai deve ser do tipo 'parcelada_pai'
        IF V_SAIDA_PAI_TIPO != 'parcelada_pai' THEN
            RAISE_APPLICATION_ERROR(-20002, 
                'Parcela filha deve referenciar uma saída pai do tipo parcelada_pai');
        END IF;
        
        -- Número da parcela não pode exceder o total de parcelas
        IF :NEW.NUMERO_PARCELA > V_SAIDA_PAI_TOTAL_PARCELAS THEN
            RAISE_APPLICATION_ERROR(-20003, 
                'Número da parcela (' || :NEW.NUMERO_PARCELA || 
                ') não pode exceder o total de parcelas (' || V_SAIDA_PAI_TOTAL_PARCELAS || ')');
        END IF;
        
        -- Verificar se já existe parcela com o mesmo número
        SELECT COUNT(*) INTO V_PARCELAS_EXISTENTES
        FROM KIG_SAIDAS
        WHERE SAIDA_PAI_ID = :NEW.SAIDA_PAI_ID
          AND NUMERO_PARCELA = :NEW.NUMERO_PARCELA
          AND (:OLD.ID IS NULL OR ID != :OLD.ID);
          
        IF V_PARCELAS_EXISTENTES > 0 THEN
            RAISE_APPLICATION_ERROR(-20004,
                'Já existe uma parcela com o número ' || :NEW.NUMERO_PARCELA);
        END IF;
        
        -- Herdar configurações da saída pai se não informadas
        IF :NEW.EMPRESA_ID IS NULL OR :NEW.TIPO_PAGAMENTO IS NULL OR :NEW.VALOR_TOTAL IS NULL THEN
            SELECT EMPRESA_ID, TIPO_PAGAMENTO, VALOR_TOTAL
            INTO :NEW.EMPRESA_ID, :NEW.TIPO_PAGAMENTO, :NEW.VALOR_TOTAL
            FROM KIG_SAIDAS
            WHERE ID = :NEW.SAIDA_PAI_ID;
        END IF;
    END IF;
    
    -- Validação para saídas parceladas pai
    IF :NEW.TIPO_SAIDA = 'parcelada_pai' THEN
        IF :NEW.TOTAL_PARCELAS IS NULL OR :NEW.TOTAL_PARCELAS < 2 THEN
            RAISE_APPLICATION_ERROR(-20005, 
                'Saída parcelada pai deve ter TOTAL_PARCELAS >= 2');
        END IF;
        
        IF :NEW.NUMERO_PARCELA != 1 THEN
            RAISE_APPLICATION_ERROR(-20006, 
                'Saída parcelada pai deve ter NUMERO_PARCELA = 1');
        END IF;
        
        IF :NEW.TIPO_PAGAMENTO != 'parcelado' THEN
            RAISE_APPLICATION_ERROR(-20007,
                'Saída parcelada pai deve ter TIPO_PAGAMENTO = parcelado');
        END IF;
    END IF;
    
    -- Validação para saídas normais
    IF :NEW.TIPO_SAIDA = 'normal' THEN
        IF :NEW.SAIDA_PAI_ID IS NOT NULL THEN
            RAISE_APPLICATION_ERROR(-20008, 
                'Saída normal não pode ter SAIDA_PAI_ID');
        END IF;
        
        IF :NEW.NUMERO_PARCELA != 1 THEN
            RAISE_APPLICATION_ERROR(-20009, 
                'Saída normal deve ter NUMERO_PARCELA = 1');
        END IF;
        
        IF :NEW.TOTAL_PARCELAS IS NOT NULL THEN
            RAISE_APPLICATION_ERROR(-20010,
                'Saída normal não pode ter TOTAL_PARCELAS');
        END IF;
    END IF;
END;
/

-- Trigger para prevenir exclusão de saídas pai que tenham parcelas filhas
CREATE OR REPLACE TRIGGER TRG_KIG_VALIDAR_EXCLUSAO_SAIDA_PAI
    BEFORE DELETE ON KIG_SAIDAS
    FOR EACH ROW
DECLARE
    V_PARCELAS_FILHAS NUMBER(3);
BEGIN
    -- Verificar se é uma saída pai que possui parcelas filhas
    IF :OLD.TIPO_SAIDA = 'parcelada_pai' THEN
        SELECT COUNT(*) INTO V_PARCELAS_FILHAS
        FROM KIG_SAIDAS
        WHERE SAIDA_PAI_ID = :OLD.ID;
        
        IF V_PARCELAS_FILHAS > 0 THEN
            RAISE_APPLICATION_ERROR(-20011,
                'Não é possível excluir saída parcelada que possui parcelas filhas');
        END IF;
    END IF;
END;
/

-- ====================================================================
-- 7. COMENTÁRIOS NAS TABELAS E COLUNAS
-- ====================================================================

-- Comentários na tabela KIG_USUARIOS
COMMENT ON TABLE KIG_USUARIOS IS 'Usuários do sistema familiar KIGI';
COMMENT ON COLUMN KIG_USUARIOS.ID IS 'Identificador único do usuário';
COMMENT ON COLUMN KIG_USUARIOS.NOME IS 'Nome completo do usuário';
COMMENT ON COLUMN KIG_USUARIOS.LOGIN IS 'Login único para acesso ao sistema';
COMMENT ON COLUMN KIG_USUARIOS.SENHA IS 'Senha criptografada do usuário';
COMMENT ON COLUMN KIG_USUARIOS.PAPEL IS 'Papel do usuário na família (pai, mae, filho, filha)';
COMMENT ON COLUMN KIG_USUARIOS.ATIVO IS 'Indica se o usuário está ativo (1) ou inativo (0)';

-- Comentários na tabela KIG_EMPRESAS
COMMENT ON TABLE KIG_EMPRESAS IS 'Empresas onde são realizadas compras no sistema KIGI';
COMMENT ON COLUMN KIG_EMPRESAS.ID IS 'Identificador único da empresa';
COMMENT ON COLUMN KIG_EMPRESAS.NOME IS 'Nome da empresa';
COMMENT ON COLUMN KIG_EMPRESAS.ATIVO IS 'Indica se a empresa está ativa (1) ou inativa (0)';

-- Comentários na tabela KIG_PRODUTOS
COMMENT ON TABLE KIG_PRODUTOS IS 'Catálogo de produtos da família no sistema KIGI';
COMMENT ON COLUMN KIG_PRODUTOS.ID IS 'Identificador único do produto';
COMMENT ON COLUMN KIG_PRODUTOS.CODIGO_BARRAS IS 'Código de barras do produto (opcional)';
COMMENT ON COLUMN KIG_PRODUTOS.NOME IS 'Nome do produto';
COMMENT ON COLUMN KIG_PRODUTOS.UNIDADE IS 'Unidade de medida (kg, un, lt, etc.)';
COMMENT ON COLUMN KIG_PRODUTOS.CLASSIFICACAO IS 'Categoria/classificação do produto';

-- Comentários na tabela KIG_ENTRADAS
COMMENT ON TABLE KIG_ENTRADAS IS 'Receitas e entradas financeiras da família no sistema KIGI';
COMMENT ON COLUMN KIG_ENTRADAS.USUARIO_REGISTRO_ID IS 'Usuário que registrou a entrada';
COMMENT ON COLUMN KIG_ENTRADAS.USUARIO_TITULAR_ID IS 'Usuário titular da receita';
COMMENT ON COLUMN KIG_ENTRADAS.DATA_REFERENCIA IS 'Data de referência da receita';
COMMENT ON COLUMN KIG_ENTRADAS.VALOR IS 'Valor da entrada em reais';
COMMENT ON COLUMN KIG_ENTRADAS.EMPRESA_PAGADORA_ID IS 'Empresa que efetuou o pagamento';

-- Comentários na tabela KIG_SAIDAS (ESTRUTURA UNIFICADA)
COMMENT ON TABLE KIG_SAIDAS IS 'Despesas e saídas financeiras unificadas - à vista e parceladas no sistema KIGI';
COMMENT ON COLUMN KIG_SAIDAS.ID IS 'Identificador único da saída';
COMMENT ON COLUMN KIG_SAIDAS.SAIDA_PAI_ID IS 'Referência à saída pai (NULL para normais e parceladas_pai)';
COMMENT ON COLUMN KIG_SAIDAS.TIPO_SAIDA IS 'Tipo: normal (à vista), parcelada_pai (primeira parcela), parcela (parcelas subsequentes)';
COMMENT ON COLUMN KIG_SAIDAS.NUMERO_PARCELA IS 'Número da parcela (1 para à vista, 1-N para parceladas)';
COMMENT ON COLUMN KIG_SAIDAS.TOTAL_PARCELAS IS 'Total de parcelas (apenas para parceladas_pai)';
COMMENT ON COLUMN KIG_SAIDAS.USUARIO_REGISTRO_ID IS 'Usuário que registrou a saída';
COMMENT ON COLUMN KIG_SAIDAS.DATA_SAIDA IS 'Data de impacto financeiro (vencimento da parcela)';
COMMENT ON COLUMN KIG_SAIDAS.EMPRESA_ID IS 'Empresa onde foi realizada a compra';
COMMENT ON COLUMN KIG_SAIDAS.TIPO_PAGAMENTO IS 'Tipo de pagamento (avista, parcelado)';
COMMENT ON COLUMN KIG_SAIDAS.VALOR_TOTAL IS 'Valor da parcela (impacto financeiro no mês)';
COMMENT ON COLUMN KIG_SAIDAS.OBSERVACAO IS 'Observações adicionais';

-- Comentários na tabela KIG_ITENS_SAIDA
COMMENT ON TABLE KIG_ITENS_SAIDA IS 'Itens individuais de cada saída/despesa no sistema KIGI';
COMMENT ON COLUMN KIG_ITENS_SAIDA.SAIDA_ID IS 'Referência à saída principal';
COMMENT ON COLUMN KIG_ITENS_SAIDA.PRODUTO_ID IS 'Referência ao produto';
COMMENT ON COLUMN KIG_ITENS_SAIDA.NOME_PRODUTO IS 'Nome do produto no momento da compra';
COMMENT ON COLUMN KIG_ITENS_SAIDA.QUANTIDADE IS 'Quantidade comprada';
COMMENT ON COLUMN KIG_ITENS_SAIDA.PRECO_UNITARIO IS 'Preço unitário no momento da compra';
COMMENT ON COLUMN KIG_ITENS_SAIDA.TOTAL IS 'Total do item (quantidade × preço unitário)';

-- Comentários na tabela KIG_SAIDA_TITULARES
COMMENT ON TABLE KIG_SAIDA_TITULARES IS 'Relacionamento entre saídas e usuários titulares no sistema KIGI';
COMMENT ON COLUMN KIG_SAIDA_TITULARES.SAIDA_ID IS 'Referência à saída';
COMMENT ON COLUMN KIG_SAIDA_TITULARES.USUARIO_ID IS 'Referência ao usuário titular';

-- ====================================================================
-- 8. VIEWS PARA RELATÓRIOS E CONSULTAS FREQUENTES
-- ====================================================================

-- View para saídas principais (apenas normais e parceladas_pai)
-- Conforme uso atual no sistema para listagem de saídas
CREATE OR REPLACE VIEW VW_KIG_SAIDAS_PRINCIPAIS AS
SELECT 
    S.*,
    E.NOME AS EMPRESA_NOME,
    U.NOME AS USUARIO_REGISTRO_NOME,
    CASE 
        WHEN S.TIPO_SAIDA = 'parcelada_pai' THEN 'Parcelado (' || S.NUMERO_PARCELA || '/' || S.TOTAL_PARCELAS || ')'
        ELSE 'À Vista'
    END AS DESCRICAO_PAGAMENTO
FROM KIG_SAIDAS S
INNER JOIN KIG_EMPRESAS E ON S.EMPRESA_ID = E.ID
INNER JOIN KIG_USUARIOS U ON S.USUARIO_REGISTRO_ID = U.ID
WHERE S.TIPO_SAIDA IN ('normal', 'parcelada_pai')
ORDER BY S.DATA_SAIDA DESC;

-- View para resumo financeiro por usuário
-- Conforme necessidades de relatórios do sistema atual
CREATE OR REPLACE VIEW VW_KIG_RESUMO_USUARIO AS
SELECT 
    U.ID,
    U.NOME,
    U.PAPEL,
    NVL(ENTRADAS.TOTAL_ENTRADAS, 0) AS TOTAL_ENTRADAS,
    NVL(SAIDAS.TOTAL_SAIDAS, 0) AS TOTAL_SAIDAS,
    NVL(ENTRADAS.TOTAL_ENTRADAS, 0) - NVL(SAIDAS.TOTAL_SAIDAS, 0) AS SALDO
FROM KIG_USUARIOS U
LEFT JOIN (
    SELECT USUARIO_TITULAR_ID, SUM(VALOR) AS TOTAL_ENTRADAS
    FROM KIG_ENTRADAS 
    WHERE EXTRACT(YEAR FROM DATA_REFERENCIA) = EXTRACT(YEAR FROM SYSDATE)
    GROUP BY USUARIO_TITULAR_ID
) ENTRADAS ON U.ID = ENTRADAS.USUARIO_TITULAR_ID
LEFT JOIN (
    SELECT ST.USUARIO_ID, SUM(S.VALOR_TOTAL) AS TOTAL_SAIDAS
    FROM KIG_SAIDAS S
    INNER JOIN KIG_SAIDA_TITULARES ST ON S.ID = ST.SAIDA_ID
    WHERE EXTRACT(YEAR FROM S.DATA_SAIDA) = EXTRACT(YEAR FROM SYSDATE)
    GROUP BY ST.USUARIO_ID
) SAIDAS ON U.ID = SAIDAS.USUARIO_ID
WHERE U.ATIVO = 1;

-- View para parcelas futuras (a vencer)
-- Fundamental para controle de vencimentos no sistema atual
CREATE OR REPLACE VIEW VW_KIG_PARCELAS_FUTURAS AS
SELECT 
    S.ID,
    S.SAIDA_PAI_ID,
    SP.DATA_SAIDA AS DATA_COMPRA_ORIGINAL,
    E.NOME AS EMPRESA,
    S.NUMERO_PARCELA,
    S.DATA_SAIDA AS DATA_VENCIMENTO,
    S.VALOR_TOTAL AS VALOR_PARCELA,
    TRUNC(S.DATA_SAIDA) - TRUNC(SYSDATE) AS DIAS_PARA_VENCIMENTO,
    U.NOME AS RESPONSAVEL,
    SP.OBSERVACAO AS OBSERVACAO_ORIGINAL
FROM KIG_SAIDAS S
INNER JOIN KIG_SAIDAS SP ON S.SAIDA_PAI_ID = SP.ID -- Join com a saída pai
INNER JOIN KIG_EMPRESAS E ON S.EMPRESA_ID = E.ID
INNER JOIN KIG_USUARIOS U ON S.USUARIO_REGISTRO_ID = U.ID
WHERE S.TIPO_SAIDA = 'parcela'
  AND S.DATA_SAIDA > SYSDATE
ORDER BY S.DATA_SAIDA;

-- View para gastos por categoria
-- Para relatórios de classificação conforme sistema atual
CREATE OR REPLACE VIEW VW_KIG_GASTOS_CATEGORIA AS
SELECT 
    P.CLASSIFICACAO,
    COUNT(*) AS TOTAL_COMPRAS,
    SUM(I.QUANTIDADE) AS QUANTIDADE_TOTAL,
    SUM(I.TOTAL) AS VALOR_TOTAL,
    AVG(I.PRECO_UNITARIO) AS PRECO_MEDIO
FROM KIG_ITENS_SAIDA I
INNER JOIN KIG_PRODUTOS P ON I.PRODUTO_ID = P.ID
INNER JOIN KIG_SAIDAS S ON I.SAIDA_ID = S.ID
WHERE EXTRACT(YEAR FROM S.DATA_SAIDA) = EXTRACT(YEAR FROM SYSDATE)
GROUP BY P.CLASSIFICACAO
ORDER BY VALOR_TOTAL DESC;

-- View para saídas com parcelas (usada no modal de detalhes)
-- Conforme funcionalidade atual do modal de detalhes de saída
CREATE OR REPLACE VIEW VW_KIG_SAIDAS_COM_PARCELAS AS
SELECT 
    SP.ID AS SAIDA_PAI_ID,
    SP.OBSERVACAO,
    SP.DATA_SAIDA AS DATA_COMPRA,
    SP.TOTAL_PARCELAS,
    E.NOME AS EMPRESA_NOME,
    U.NOME AS USUARIO_NOME,
    S.ID AS PARCELA_ID,
    S.NUMERO_PARCELA,
    S.DATA_SAIDA AS DATA_VENCIMENTO,
    S.VALOR_TOTAL AS VALOR_PARCELA,
    CASE 
        WHEN S.DATA_SAIDA <= SYSDATE THEN 'Vencida'
        WHEN S.DATA_SAIDA = TRUNC(SYSDATE) THEN 'Vence Hoje'
        ELSE 'A Vencer'
    END AS STATUS_PARCELA
FROM KIG_SAIDAS SP
INNER JOIN KIG_EMPRESAS E ON SP.EMPRESA_ID = E.ID
INNER JOIN KIG_USUARIOS U ON SP.USUARIO_REGISTRO_ID = U.ID
LEFT JOIN KIG_SAIDAS S ON SP.ID = S.SAIDA_PAI_ID
WHERE SP.TIPO_SAIDA = 'parcelada_pai'
ORDER BY SP.DATA_SAIDA DESC, S.NUMERO_PARCELA;

-- ====================================================================
-- 9. PROCEDURES PARA OPERAÇÕES ESPECÍFICAS DO SISTEMA
-- ====================================================================

-- Procedure para criar saída parcelada automaticamente
-- Conforme funcionalidade de criação de parcelas no sistema atual
CREATE OR REPLACE PROCEDURE SP_KIG_CRIAR_SAIDA_PARCELADA(
    P_USUARIO_REGISTRO_ID IN NUMBER,
    P_EMPRESA_ID IN NUMBER,
    P_VALOR_PARCELA IN NUMBER,
    P_TOTAL_PARCELAS IN NUMBER,
    P_DATA_PRIMEIRA_PARCELA IN DATE,
    P_OBSERVACAO IN VARCHAR2 DEFAULT NULL,
    P_USUARIOS_TITULARES IN VARCHAR2, -- IDs separados por vírgula
    P_SAIDA_PAI_ID OUT NUMBER
) AS
    V_DATA_PARCELA DATE;
    V_USUARIO_ID NUMBER;
    V_POS NUMBER;
    V_USUARIOS_STR VARCHAR2(4000);
BEGIN
    -- Inserir a saída pai (primeira parcela)
    INSERT INTO KIG_SAIDAS (
        TIPO_SAIDA, NUMERO_PARCELA, TOTAL_PARCELAS,
        USUARIO_REGISTRO_ID, DATA_SAIDA, EMPRESA_ID,
        TIPO_PAGAMENTO, VALOR_TOTAL, OBSERVACAO
    ) VALUES (
        'parcelada_pai', 1, P_TOTAL_PARCELAS,
        P_USUARIO_REGISTRO_ID, P_DATA_PRIMEIRA_PARCELA, P_EMPRESA_ID,
        'parcelado', P_VALOR_PARCELA, P_OBSERVACAO
    ) RETURNING ID INTO P_SAIDA_PAI_ID;
    
    -- Inserir as parcelas subsequentes
    FOR I IN 2..P_TOTAL_PARCELAS LOOP
        V_DATA_PARCELA := ADD_MONTHS(P_DATA_PRIMEIRA_PARCELA, I-1);
        
        INSERT INTO KIG_SAIDAS (
            SAIDA_PAI_ID, TIPO_SAIDA, NUMERO_PARCELA,
            USUARIO_REGISTRO_ID, DATA_SAIDA, EMPRESA_ID,
            TIPO_PAGAMENTO, VALOR_TOTAL
        ) VALUES (
            P_SAIDA_PAI_ID, 'parcela', I,
            P_USUARIO_REGISTRO_ID, V_DATA_PARCELA, P_EMPRESA_ID,
            'parcelado', P_VALOR_PARCELA
        );
    END LOOP;
    
    -- Inserir usuários titulares para a saída pai
    V_USUARIOS_STR := P_USUARIOS_TITULARES || ',';
    WHILE LENGTH(V_USUARIOS_STR) > 0 LOOP
        V_POS := INSTR(V_USUARIOS_STR, ',');
        IF V_POS > 0 THEN
            V_USUARIO_ID := TO_NUMBER(SUBSTR(V_USUARIOS_STR, 1, V_POS - 1));
            INSERT INTO KIG_SAIDA_TITULARES (SAIDA_ID, USUARIO_ID) 
            VALUES (P_SAIDA_PAI_ID, V_USUARIO_ID);
            V_USUARIOS_STR := SUBSTR(V_USUARIOS_STR, V_POS + 1);
        ELSE
            EXIT;
        END IF;
    END LOOP;
    
    COMMIT;
END;
/

-- Procedure para adicionar nova parcela a uma saída parcelada existente
-- Conforme funcionalidade do modal de detalhes atual
CREATE OR REPLACE PROCEDURE SP_KIG_ADICIONAR_PARCELA(
    P_SAIDA_PAI_ID IN NUMBER,
    P_NOVA_PARCELA_ID OUT NUMBER
) AS
    V_ULTIMO_NUMERO NUMBER;
    V_NOVA_DATA DATE;
    V_USUARIO_REGISTRO_ID NUMBER;
    V_EMPRESA_ID NUMBER;
    V_VALOR_TOTAL NUMBER;
BEGIN
    -- Verificar se é uma saída parcelada válida
    SELECT USUARIO_REGISTRO_ID, EMPRESA_ID, VALOR_TOTAL
    INTO V_USUARIO_REGISTRO_ID, V_EMPRESA_ID, V_VALOR_TOTAL
    FROM KIG_SAIDAS
    WHERE ID = P_SAIDA_PAI_ID AND TIPO_SAIDA = 'parcelada_pai';
    
    -- Obter o último número de parcela
    SELECT NVL(MAX(NUMERO_PARCELA), 0) INTO V_ULTIMO_NUMERO
    FROM KIG_SAIDAS
    WHERE SAIDA_PAI_ID = P_SAIDA_PAI_ID OR ID = P_SAIDA_PAI_ID;
    
    -- Calcular data da nova parcela (um mês após a última)
    SELECT ADD_MONTHS(MAX(DATA_SAIDA), 1) INTO V_NOVA_DATA
    FROM KIG_SAIDAS
    WHERE SAIDA_PAI_ID = P_SAIDA_PAI_ID OR ID = P_SAIDA_PAI_ID;
    
    -- Inserir nova parcela
    INSERT INTO KIG_SAIDAS (
        SAIDA_PAI_ID, TIPO_SAIDA, NUMERO_PARCELA,
        USUARIO_REGISTRO_ID, DATA_SAIDA, EMPRESA_ID,
        TIPO_PAGAMENTO, VALOR_TOTAL
    ) VALUES (
        P_SAIDA_PAI_ID, 'parcela', V_ULTIMO_NUMERO + 1,
        V_USUARIO_REGISTRO_ID, V_NOVA_DATA, V_EMPRESA_ID,
        'parcelado', V_VALOR_TOTAL
    ) RETURNING ID INTO P_NOVA_PARCELA_ID;
    
    -- Atualizar total de parcelas na saída pai
    UPDATE KIG_SAIDAS 
    SET TOTAL_PARCELAS = V_ULTIMO_NUMERO + 1
    WHERE ID = P_SAIDA_PAI_ID;
    
    COMMIT;
END;
/

-- Procedure para remover parcela (mantendo mínimo de 2)
-- Conforme regra de negócio do sistema atual
CREATE OR REPLACE PROCEDURE SP_KIG_REMOVER_PARCELA(
    P_PARCELA_ID IN NUMBER
) AS
    V_SAIDA_PAI_ID NUMBER;
    V_TOTAL_PARCELAS NUMBER;
    V_NUMERO_PARCELA NUMBER;
BEGIN
    -- Obter dados da parcela
    SELECT SAIDA_PAI_ID, NUMERO_PARCELA
    INTO V_SAIDA_PAI_ID, V_NUMERO_PARCELA
    FROM KIG_SAIDAS
    WHERE ID = P_PARCELA_ID AND TIPO_SAIDA = 'parcela';
    
    -- Contar parcelas existentes
    SELECT COUNT(*) INTO V_TOTAL_PARCELAS
    FROM KIG_SAIDAS
    WHERE SAIDA_PAI_ID = V_SAIDA_PAI_ID OR ID = V_SAIDA_PAI_ID;
    
    -- Verificar se pode remover (mínimo 2 parcelas)
    IF V_TOTAL_PARCELAS <= 2 THEN
        RAISE_APPLICATION_ERROR(-20012,
            'Não é possível remover parcela. Mínimo de 2 parcelas necessário.');
    END IF;
    
    -- Remover a parcela
    DELETE FROM KIG_SAIDAS WHERE ID = P_PARCELA_ID;
    
    -- Atualizar total de parcelas na saída pai
    UPDATE KIG_SAIDAS 
    SET TOTAL_PARCELAS = V_TOTAL_PARCELAS - 1
    WHERE ID = V_SAIDA_PAI_ID;
    
    COMMIT;
END;
/

-- ====================================================================
-- 10. DADOS INICIAIS (SEEDS) CONFORME MOCK ATUAL
-- ====================================================================

-- Inserir usuários iniciais conforme mockData atual
INSERT INTO KIG_USUARIOS (NOME, LOGIN, SENHA, PAPEL) VALUES 
('Administrador', 'admin', '$2a$10$hashedpassword', 'pai');

INSERT INTO KIG_USUARIOS (NOME, LOGIN, SENHA, PAPEL) VALUES 
('João Silva', 'joao', '$2a$10$hashedpassword', 'pai');

INSERT INTO KIG_USUARIOS (NOME, LOGIN, SENHA, PAPEL) VALUES 
('Maria Silva', 'maria', '$2a$10$hashedpassword', 'mae');

INSERT INTO KIG_USUARIOS (NOME, LOGIN, SENHA, PAPEL) VALUES 
('Pedro Silva', 'pedro', '$2a$10$hashedpassword', 'filho');

INSERT INTO KIG_USUARIOS (NOME, LOGIN, SENHA, PAPEL) VALUES 
('Ana Silva', 'ana', '$2a$10$hashedpassword', 'filha');

-- Inserir empresas iniciais conforme mockData atual
INSERT INTO KIG_EMPRESAS (NOME) VALUES ('Supermercado ABC');
INSERT INTO KIG_EMPRESAS (NOME) VALUES ('Farmácia Central');
INSERT INTO KIG_EMPRESAS (NOME) VALUES ('Posto Shell');
INSERT INTO KIG_EMPRESAS (NOME) VALUES ('Magazine Luiza');
INSERT INTO KIG_EMPRESAS (NOME) VALUES ('Padaria do João');
INSERT INTO KIG_EMPRESAS (NOME) VALUES ('Açougue Premium');
INSERT INTO KIG_EMPRESAS (NOME) VALUES ('Loja de Roupas Fashion');

-- Inserir produtos iniciais conforme mockData atual
INSERT INTO KIG_PRODUTOS (CODIGO_BARRAS, NOME, UNIDADE, CLASSIFICACAO) VALUES 
('7891234567890', 'Arroz Integral 5kg', 'kg', 'Alimentação');

INSERT INTO KIG_PRODUTOS (CODIGO_BARRAS, NOME, UNIDADE, CLASSIFICACAO) VALUES 
('7891234567891', 'Feijão Preto 1kg', 'kg', 'Alimentação');

INSERT INTO KIG_PRODUTOS (CODIGO_BARRAS, NOME, UNIDADE, CLASSIFICACAO) VALUES 
('7891234567892', 'Óleo de Soja 900ml', 'ml', 'Alimentação');

INSERT INTO KIG_PRODUTOS (CODIGO_BARRAS, NOME, UNIDADE, CLASSIFICACAO) VALUES 
('7891234567893', 'Smartphone Samsung', 'un', 'Eletrônicos');

INSERT INTO KIG_PRODUTOS (CODIGO_BARRAS, NOME, UNIDADE, CLASSIFICACAO) VALUES 
('7891234567894', 'Leite Integral 1L', 'L', 'Alimentação');

INSERT INTO KIG_PRODUTOS (CODIGO_BARRAS, NOME, UNIDADE, CLASSIFICACAO) VALUES 
('7891234567895', 'Pão de Forma', 'un', 'Alimentação');

INSERT INTO KIG_PRODUTOS (CODIGO_BARRAS, NOME, UNIDADE, CLASSIFICACAO) VALUES 
('7891234567896', 'Detergente Líquido', 'un', 'Limpeza');

-- Inserir exemplos de entradas conforme sistema atual
INSERT INTO KIG_ENTRADAS (USUARIO_REGISTRO_ID, USUARIO_TITULAR_ID, DATA_REFERENCIA, VALOR, EMPRESA_PAGADORA_ID) 
VALUES (1, 1, DATE '2024-01-01', 5000.00, 1);

INSERT INTO KIG_ENTRADAS (USUARIO_REGISTRO_ID, USUARIO_TITULAR_ID, DATA_REFERENCIA, VALOR, EMPRESA_PAGADORA_ID) 
VALUES (1, 2, DATE '2024-01-01', 3000.00, 2);

INSERT INTO KIG_ENTRADAS (USUARIO_REGISTRO_ID, USUARIO_TITULAR_ID, DATA_REFERENCIA, VALOR, EMPRESA_PAGADORA_ID) 
VALUES (2, 2, DATE '2024-01-15', 2500.00, 3);

-- Exemplos de saídas à vista conforme sistema atual
INSERT INTO KIG_SAIDAS (TIPO_SAIDA, NUMERO_PARCELA, USUARIO_REGISTRO_ID, DATA_SAIDA, EMPRESA_ID, TIPO_PAGAMENTO, VALOR_TOTAL, OBSERVACAO) 
VALUES ('normal', 1, 1, DATE '2024-01-05', 1, 'avista', 250.00, 'Compras do mês');

INSERT INTO KIG_SAIDAS (TIPO_SAIDA, NUMERO_PARCELA, USUARIO_REGISTRO_ID, DATA_SAIDA, EMPRESA_ID, TIPO_PAGAMENTO, VALOR_TOTAL, OBSERVACAO) 
VALUES ('normal', 1, 2, DATE '2024-01-10', 5, 'avista', 45.00, 'Pães e leite');

-- Exemplo de saída parcelada - Primeira parcela (saída pai)
INSERT INTO KIG_SAIDAS (TIPO_SAIDA, NUMERO_PARCELA, TOTAL_PARCELAS, USUARIO_REGISTRO_ID, DATA_SAIDA, EMPRESA_ID, TIPO_PAGAMENTO, VALOR_TOTAL, OBSERVACAO) 
VALUES ('parcelada_pai', 1, 3, 1, DATE '2024-01-15', 4, 'parcelado', 400.00, 'Smartphone parcelado em 3x');

-- Parcelas subsequentes da saída parcelada
INSERT INTO KIG_SAIDAS (SAIDA_PAI_ID, TIPO_SAIDA, NUMERO_PARCELA, USUARIO_REGISTRO_ID, DATA_SAIDA, EMPRESA_ID, TIPO_PAGAMENTO, VALOR_TOTAL) 
VALUES (3, 'parcela', 2, 1, DATE '2024-02-15', 4, 'parcelado', 400.00);

INSERT INTO KIG_SAIDAS (SAIDA_PAI_ID, TIPO_SAIDA, NUMERO_PARCELA, USUARIO_REGISTRO_ID, DATA_SAIDA, EMPRESA_ID, TIPO_PAGAMENTO, VALOR_TOTAL) 
VALUES (3, 'parcela', 3, 1, DATE '2024-03-15', 4, 'parcelado', 400.00);

-- Inserir itens para as saídas conforme estrutura atual
INSERT INTO KIG_ITENS_SAIDA (SAIDA_ID, PRODUTO_ID, NOME_PRODUTO, QUANTIDADE, PRECO_UNITARIO, TOTAL) 
VALUES (1, 1, 'Arroz Integral 5kg', 2, 25.00, 50.00);

INSERT INTO KIG_ITENS_SAIDA (SAIDA_ID, PRODUTO_ID, NOME_PRODUTO, QUANTIDADE, PRECO_UNITARIO, TOTAL) 
VALUES (1, 2, 'Feijão Preto 1kg', 3, 8.00, 24.00);

INSERT INTO KIG_ITENS_SAIDA (SAIDA_ID, PRODUTO_ID, NOME_PRODUTO, QUANTIDADE, PRECO_UNITARIO, TOTAL) 
VALUES (1, 3, 'Óleo de Soja 900ml', 4, 6.50, 26.00);

INSERT INTO KIG_ITENS_SAIDA (SAIDA_ID, PRODUTO_ID, NOME_PRODUTO, QUANTIDADE, PRECO_UNITARIO, TOTAL) 
VALUES (2, 5, 'Leite Integral 1L', 2, 4.50, 9.00);

INSERT INTO KIG_ITENS_SAIDA (SAIDA_ID, PRODUTO_ID, NOME_PRODUTO, QUANTIDADE, PRECO_UNITARIO, TOTAL) 
VALUES (2, 6, 'Pão de Forma', 3, 6.00, 18.00);

-- Itens para a saída parcelada (apenas na primeira parcela)
INSERT INTO KIG_ITENS_SAIDA (SAIDA_ID, PRODUTO_ID, NOME_PRODUTO, QUANTIDADE, PRECO_UNITARIO, TOTAL) 
VALUES (3, 4, 'Smartphone Samsung', 1, 1200.00, 1200.00);

-- Inserir titulares das saídas conforme sistema atual
INSERT INTO KIG_SAIDA_TITULARES (SAIDA_ID, USUARIO_ID) VALUES (1, 1);
INSERT INTO KIG_SAIDA_TITULARES (SAIDA_ID, USUARIO_ID) VALUES (1, 2);
INSERT INTO KIG_SAIDA_TITULARES (SAIDA_ID, USUARIO_ID) VALUES (2, 2);
INSERT INTO KIG_SAIDA_TITULARES (SAIDA_ID, USUARIO_ID) VALUES (3, 1);

-- Commit das inserções iniciais
COMMIT;

-- ====================================================================
-- 11. FUNÇÕES AUXILIARES PARA RELATÓRIOS
-- ====================================================================

-- Função para calcular saldo familiar atual
CREATE OR REPLACE FUNCTION FN_KIG_SALDO_FAMILIAR RETURN NUMBER AS
    V_TOTAL_ENTRADAS NUMBER(15,2);
    V_TOTAL_SAIDAS NUMBER(15,2);
BEGIN
    SELECT NVL(SUM(VALOR), 0) INTO V_TOTAL_ENTRADAS
    FROM KIG_ENTRADAS;
    
    SELECT NVL(SUM(VALOR_TOTAL), 0) INTO V_TOTAL_SAIDAS
    FROM KIG_SAIDAS;
    
    RETURN V_TOTAL_ENTRADAS - V_TOTAL_SAIDAS;
END;
/

-- Função para calcular total de parcelas pendentes
CREATE OR REPLACE FUNCTION FN_KIG_PARCELAS_PENDENTES RETURN NUMBER AS
    V_TOTAL_PENDENTE NUMBER(15,2);
BEGIN
    SELECT NVL(SUM(VALOR_TOTAL), 0) INTO V_TOTAL_PENDENTE
    FROM KIG_SAIDAS
    WHERE TIPO_SAIDA = 'parcela'
      AND DATA_SAIDA > SYSDATE;
    
    RETURN V_TOTAL_PENDENTE;
END;
/

-- ====================================================================
-- 12. GRANTS E PERMISSÕES (OPCIONAL - CONFORME AMBIENTE)
-- ====================================================================

-- Exemplo de grants para usuário da aplicação (ajustar conforme necessário)
-- GRANT SELECT, INSERT, UPDATE, DELETE ON KIG_USUARIOS TO KIGI_APP_USER;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON KIG_EMPRESAS TO KIGI_APP_USER;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON KIG_PRODUTOS TO KIGI_APP_USER;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON KIG_ENTRADAS TO KIGI_APP_USER;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON KIG_SAIDAS TO KIGI_APP_USER;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON KIG_ITENS_SAIDA TO KIGI_APP_USER;
-- GRANT SELECT, INSERT, UPDATE, DELETE ON KIG_SAIDA_TITULARES TO KIGI_APP_USER;

-- GRANT EXECUTE ON SP_KIG_CRIAR_SAIDA_PARCELADA TO KIGI_APP_USER;
-- GRANT EXECUTE ON SP_KIG_ADICIONAR_PARCELA TO KIGI_APP_USER;
-- GRANT EXECUTE ON SP_KIG_REMOVER_PARCELA TO KIGI_APP_USER;
-- GRANT EXECUTE ON FN_KIG_SALDO_FAMILIAR TO KIGI_APP_USER;
-- GRANT EXECUTE ON FN_KIG_PARCELAS_PENDENTES TO KIGI_APP_USER;

-- ====================================================================
-- FIM DOS SCRIPTS - SISTEMA KIGI ATUALIZADO
-- ====================================================================

/*
RESUMO DAS ATUALIZAÇÕES REALIZADAS:

1. PREFIXO KIG_:
   - Todos os objetos de banco agora usam prefixo "KIG_"
   - Sequences, tabelas, índices, triggers, constraints, views, procedures

2. ESTRUTURA ATUALIZADA CONFORME SISTEMA ATUAL:
   - Campos e tipos de dados alinhados com interfaces TypeScript
   - Constraints de validação atualizadas
   - Relacionamentos conforme uso real no sistema

3. FUNCIONALIDADES ESPECÍFICAS IMPLEMENTADAS:
   - Modal de detalhes de saída com parcelas
   - Adição/remoção de parcelas com validações
   - Estrutura unificada de saídas conforme sistema atual

4. VALIDAÇÕES E INTEGRIDADE:
   - Triggers específicos para estrutura de parcelas
   - Validações de negócio conforme regras do sistema
   - Prevenção de inconsistências de dados

5. VIEWS E RELATÓRIOS:
   - Views específicas para funcionalidades atuais
   - Suporte a relatórios conforme necessidades do sistema
   - Otimização para consultas frequentes

6. PROCEDURES E FUNÇÕES:
   - Operações complexas automatizadas
   - Suporte às funcionalidades do modal de parcelas
   - Cálculos financeiros automatizados

7. DADOS INICIAIS:
   - Seeds conforme mockData atual
   - Exemplos representativos do uso real
   - Dados para testes e demonstração

COMPATIBILIDADE:
- Oracle Database 11G e superiores
- Estrutura preparada para migração de dados existentes
- Performance otimizada com índices apropriados
- Flexibilidade para futuras expansões

OBSERVAÇÕES IMPORTANTES:
- Executar scripts em ordem sequencial
- Ajustar grants conforme ambiente de produção
- Testar procedures antes do uso em produção
- Monitorar performance das views em grandes volumes
*/
